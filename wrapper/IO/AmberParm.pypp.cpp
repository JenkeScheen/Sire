// This file has been generated by Py++.

// (C) Christopher Woods, GPL >= 2 License

#include "boost/python.hpp"
#include "AmberParm.pypp.hpp"

namespace bp = boost::python;

#include "SireBase/parallel.h"

#include "SireBase/unittest.h"

#include "SireError/errors.h"

#include "SireMol/molecule.h"

#include "SireStream/datastream.h"

#include "SireStream/shareddatastream.h"

#include "SireSystem/system.h"

#include "amber2.h"

#include <QElapsedTimer>

#include <QFile>

#include <QHash>

#include <QRegularExpression>

#include <QTextStream>

#include "amber2.h"

SireIO::AmberParm __copy__(const SireIO::AmberParm &other){ return SireIO::AmberParm(other); }

#include "Qt/qdatastream.hpp"

#include "Helpers/str.hpp"

void register_AmberParm_class(){

    { //::SireIO::AmberParm
        typedef bp::class_< SireIO::AmberParm, bp::bases< SireIO::MoleculeParser, SireBase::Property > > AmberParm_exposer_t;
        AmberParm_exposer_t AmberParm_exposer = AmberParm_exposer_t( "AmberParm", "This class represents an Amber-format parameter file, currently\nsupporting top files produced from Amber7 until Amber16\n\nThe format of this file is described here;\n\nhttp:ambermd.orgformats.html\n\n(specifically the PARM parametertopology file specification)\n\nAuthor: Christopher Woods\n", bp::init< >("Constructor") );
        bp::scope AmberParm_scope( AmberParm_exposer );
        bp::enum_< SireIO::AmberParm::FLAG_TYPE>("FLAG_TYPE")
            .value("UNKNOWN", SireIO::AmberParm::UNKNOWN)
            .value("INTEGER", SireIO::AmberParm::INTEGER)
            .value("FLOAT", SireIO::AmberParm::FLOAT)
            .value("STRING", SireIO::AmberParm::STRING)
            .export_values()
            ;
        AmberParm_exposer.def( bp::init< QString const &, bp::optional< SireBase::PropertyMap const & > >(( bp::arg("filename"), bp::arg("map")=SireBase::PropertyMap() ), "Construct by reading from the file called filename") );
        AmberParm_exposer.def( bp::init< SireSystem::System const &, bp::optional< SireBase::PropertyMap const & > >(( bp::arg("system"), bp::arg("map")=SireBase::PropertyMap() ), "Construct by converting from the passed system, using the passed property\nmap to find the right properties") );
        AmberParm_exposer.def( bp::init< SireIO::AmberParm const & >(( bp::arg("other") ), "Copy constructor") );
        { //::SireIO::AmberParm::assertSane
        
            typedef void ( ::SireIO::AmberParm::*assertSane_function_type)(  ) const;
            assertSane_function_type assertSane_function_value( &::SireIO::AmberParm::assertSane );
            
            AmberParm_exposer.def( 
                "assertSane"
                , assertSane_function_value
                , "Run through all of the data that has been read and perform a series\nof tests that will see if the prm7 data is sane. If any test fails,\nthen an exception will be thrown" );
        
        }
        { //::SireIO::AmberParm::flagType
        
            typedef ::SireIO::AmberParm::FLAG_TYPE ( ::SireIO::AmberParm::*flagType_function_type)( ::QString const & ) const;
            flagType_function_type flagType_function_value( &::SireIO::AmberParm::flagType );
            
            AmberParm_exposer.def( 
                "flagType"
                , flagType_function_value
                , ( bp::arg("flag") )
                , "Return the flag type for the data associated with the passed flag.\nThis returns UNKNOWN if this is not known" );
        
        }
        { //::SireIO::AmberParm::flags
        
            typedef ::QStringList ( ::SireIO::AmberParm::*flags_function_type)(  ) const;
            flags_function_type flags_function_value( &::SireIO::AmberParm::flags );
            
            AmberParm_exposer.def( 
                "flags"
                , flags_function_value
                , "Return all of the flags that are held in this file" );
        
        }
        { //::SireIO::AmberParm::floatData
        
            typedef ::QVector< double > ( ::SireIO::AmberParm::*floatData_function_type)( ::QString const & ) const;
            floatData_function_type floatData_function_value( &::SireIO::AmberParm::floatData );
            
            AmberParm_exposer.def( 
                "floatData"
                , floatData_function_value
                , ( bp::arg("flag") )
                , "Return the float data for the passed flag. This returns an empty\nlist if there is no data associated with this flag. This raises\nan invalid_cast error if data exists, but it is the wrong type" );
        
        }
        { //::SireIO::AmberParm::getMolecule
        
            typedef ::SireMol::Molecule ( ::SireIO::AmberParm::*getMolecule_function_type)( int,::SireBase::PropertyMap const & ) const;
            getMolecule_function_type getMolecule_function_value( &::SireIO::AmberParm::getMolecule );
            
            AmberParm_exposer.def( 
                "getMolecule"
                , getMolecule_function_value
                , ( bp::arg("i"), bp::arg("map")=SireBase::PropertyMap() )
                , "Internal function used to get the molecule that starts at index start_idx\nin the file, and that has natoms atoms" );
        
        }
        { //::SireIO::AmberParm::getMolecule
        
            typedef ::SireMol::Molecule ( ::SireIO::AmberParm::*getMolecule_function_type)( int,::SireIO::AmberRst const &,::SireBase::PropertyMap const & ) const;
            getMolecule_function_type getMolecule_function_value( &::SireIO::AmberParm::getMolecule );
            
            AmberParm_exposer.def( 
                "getMolecule"
                , getMolecule_function_value
                , ( bp::arg("i"), bp::arg("rst"), bp::arg("map")=SireBase::PropertyMap() )
                , "" );
        
        }
        { //::SireIO::AmberParm::intData
        
            typedef ::QVector< long long > ( ::SireIO::AmberParm::*intData_function_type)( ::QString const & ) const;
            intData_function_type intData_function_value( &::SireIO::AmberParm::intData );
            
            AmberParm_exposer.def( 
                "intData"
                , intData_function_value
                , ( bp::arg("flag") )
                , "Return the integer data for the passed flag. This returns an empty\nlist if there is no data associated with this flag. This raises\nan invalid_cast error if data exists, but it is the wrong type" );
        
        }
        { //::SireIO::AmberParm::isLead
        
            typedef bool ( ::SireIO::AmberParm::*isLead_function_type)(  ) const;
            isLead_function_type isLead_function_value( &::SireIO::AmberParm::isLead );
            
            AmberParm_exposer.def( 
                "isLead"
                , isLead_function_value
                , "" );
        
        }
        { //::SireIO::AmberParm::linesForFlag
        
            typedef ::QVector< QString > ( ::SireIO::AmberParm::*linesForFlag_function_type)( ::QString const & ) const;
            linesForFlag_function_type linesForFlag_function_value( &::SireIO::AmberParm::linesForFlag );
            
            AmberParm_exposer.def( 
                "linesForFlag"
                , linesForFlag_function_value
                , ( bp::arg("flag") )
                , "" );
        
        }
        { //::SireIO::AmberParm::nAngles
        
            typedef int ( ::SireIO::AmberParm::*nAngles_function_type)(  ) const;
            nAngles_function_type nAngles_function_value( &::SireIO::AmberParm::nAngles );
            
            AmberParm_exposer.def( 
                "nAngles"
                , nAngles_function_value
                , "Return the number of angles" );
        
        }
        { //::SireIO::AmberParm::nAnglesNoHydrogen
        
            typedef int ( ::SireIO::AmberParm::*nAnglesNoHydrogen_function_type)(  ) const;
            nAnglesNoHydrogen_function_type nAnglesNoHydrogen_function_value( &::SireIO::AmberParm::nAnglesNoHydrogen );
            
            AmberParm_exposer.def( 
                "nAnglesNoHydrogen"
                , nAnglesNoHydrogen_function_value
                , "Return the number of angles without hydrogen" );
        
        }
        { //::SireIO::AmberParm::nAnglesWithHydrogen
        
            typedef int ( ::SireIO::AmberParm::*nAnglesWithHydrogen_function_type)(  ) const;
            nAnglesWithHydrogen_function_type nAnglesWithHydrogen_function_value( &::SireIO::AmberParm::nAnglesWithHydrogen );
            
            AmberParm_exposer.def( 
                "nAnglesWithHydrogen"
                , nAnglesWithHydrogen_function_value
                , "Return the number of angles containing hydrogen" );
        
        }
        { //::SireIO::AmberParm::nAtoms
        
            typedef int ( ::SireIO::AmberParm::*nAtoms_function_type)(  ) const;
            nAtoms_function_type nAtoms_function_value( &::SireIO::AmberParm::nAtoms );
            
            AmberParm_exposer.def( 
                "nAtoms"
                , nAtoms_function_value
                , "Return the total number of atoms in the file" );
        
        }
        { //::SireIO::AmberParm::nAtoms
        
            typedef int ( ::SireIO::AmberParm::*nAtoms_function_type)( int ) const;
            nAtoms_function_type nAtoms_function_value( &::SireIO::AmberParm::nAtoms );
            
            AmberParm_exposer.def( 
                "nAtoms"
                , nAtoms_function_value
                , ( bp::arg("molidx") )
                , "Return the total number of atoms in the ith molecule in the file" );
        
        }
        { //::SireIO::AmberParm::nBonds
        
            typedef int ( ::SireIO::AmberParm::*nBonds_function_type)(  ) const;
            nBonds_function_type nBonds_function_value( &::SireIO::AmberParm::nBonds );
            
            AmberParm_exposer.def( 
                "nBonds"
                , nBonds_function_value
                , "Return the total number of bonds" );
        
        }
        { //::SireIO::AmberParm::nBondsNoHydrogen
        
            typedef int ( ::SireIO::AmberParm::*nBondsNoHydrogen_function_type)(  ) const;
            nBondsNoHydrogen_function_type nBondsNoHydrogen_function_value( &::SireIO::AmberParm::nBondsNoHydrogen );
            
            AmberParm_exposer.def( 
                "nBondsNoHydrogen"
                , nBondsNoHydrogen_function_value
                , "Return the number of bonds no containing hydrogen" );
        
        }
        { //::SireIO::AmberParm::nBondsWithHydrogen
        
            typedef int ( ::SireIO::AmberParm::*nBondsWithHydrogen_function_type)(  ) const;
            nBondsWithHydrogen_function_type nBondsWithHydrogen_function_value( &::SireIO::AmberParm::nBondsWithHydrogen );
            
            AmberParm_exposer.def( 
                "nBondsWithHydrogen"
                , nBondsWithHydrogen_function_value
                , "Return the number of bonds including hydrogen" );
        
        }
        { //::SireIO::AmberParm::nDihedrals
        
            typedef int ( ::SireIO::AmberParm::*nDihedrals_function_type)(  ) const;
            nDihedrals_function_type nDihedrals_function_value( &::SireIO::AmberParm::nDihedrals );
            
            AmberParm_exposer.def( 
                "nDihedrals"
                , nDihedrals_function_value
                , "Return the number of dihedrals" );
        
        }
        { //::SireIO::AmberParm::nDihedralsNoHydrogen
        
            typedef int ( ::SireIO::AmberParm::*nDihedralsNoHydrogen_function_type)(  ) const;
            nDihedralsNoHydrogen_function_type nDihedralsNoHydrogen_function_value( &::SireIO::AmberParm::nDihedralsNoHydrogen );
            
            AmberParm_exposer.def( 
                "nDihedralsNoHydrogen"
                , nDihedralsNoHydrogen_function_value
                , "Return the number of dihedrals without hydrogen" );
        
        }
        { //::SireIO::AmberParm::nDihedralsWithHydrogen
        
            typedef int ( ::SireIO::AmberParm::*nDihedralsWithHydrogen_function_type)(  ) const;
            nDihedralsWithHydrogen_function_type nDihedralsWithHydrogen_function_value( &::SireIO::AmberParm::nDihedralsWithHydrogen );
            
            AmberParm_exposer.def( 
                "nDihedralsWithHydrogen"
                , nDihedralsWithHydrogen_function_value
                , "Return the number of dihedrals containing hydrogen" );
        
        }
        { //::SireIO::AmberParm::nExcluded
        
            typedef int ( ::SireIO::AmberParm::*nExcluded_function_type)(  ) const;
            nExcluded_function_type nExcluded_function_value( &::SireIO::AmberParm::nExcluded );
            
            AmberParm_exposer.def( 
                "nExcluded"
                , nExcluded_function_value
                , "Return the number of excluded atoms" );
        
        }
        { //::SireIO::AmberParm::nMolecules
        
            typedef int ( ::SireIO::AmberParm::*nMolecules_function_type)(  ) const;
            nMolecules_function_type nMolecules_function_value( &::SireIO::AmberParm::nMolecules );
            
            AmberParm_exposer.def( 
                "nMolecules"
                , nMolecules_function_value
                , "Return the number of molecules in the file" );
        
        }
        { //::SireIO::AmberParm::nResidues
        
            typedef int ( ::SireIO::AmberParm::*nResidues_function_type)(  ) const;
            nResidues_function_type nResidues_function_value( &::SireIO::AmberParm::nResidues );
            
            AmberParm_exposer.def( 
                "nResidues"
                , nResidues_function_value
                , "Return the number of residues" );
        
        }
        { //::SireIO::AmberParm::nTypes
        
            typedef int ( ::SireIO::AmberParm::*nTypes_function_type)(  ) const;
            nTypes_function_type nTypes_function_value( &::SireIO::AmberParm::nTypes );
            
            AmberParm_exposer.def( 
                "nTypes"
                , nTypes_function_value
                , "Return the number of distinct atom types" );
        
        }
        AmberParm_exposer.def( bp::self != bp::self );
        { //::SireIO::AmberParm::operator=
        
            typedef ::SireIO::AmberParm & ( ::SireIO::AmberParm::*assign_function_type)( ::SireIO::AmberParm const & ) ;
            assign_function_type assign_function_value( &::SireIO::AmberParm::operator= );
            
            AmberParm_exposer.def( 
                "assign"
                , assign_function_value
                , ( bp::arg("other") )
                , bp::return_self< >()
                , "" );
        
        }
        AmberParm_exposer.def( bp::self == bp::self );
        { //::SireIO::AmberParm::parse
        
            typedef ::SireIO::AmberParm ( *parse_function_type )( ::QString const &,::SireBase::PropertyMap const & );
            parse_function_type parse_function_value( &::SireIO::AmberParm::parse );
            
            AmberParm_exposer.def( 
                "parse"
                , parse_function_value
                , ( bp::arg("filename"), bp::arg("map")=SireBase::PropertyMap() )
                , "Return an AmberParm object parsed from the passed file" );
        
        }
        { //::SireIO::AmberParm::stringData
        
            typedef ::QVector< QString > ( ::SireIO::AmberParm::*stringData_function_type)( ::QString const & ) const;
            stringData_function_type stringData_function_value( &::SireIO::AmberParm::stringData );
            
            AmberParm_exposer.def( 
                "stringData"
                , stringData_function_value
                , ( bp::arg("flag") )
                , "Return the string data for the passed flag. This returns an empty\nlist if there is no data associated with this flag. This raises\nan invalid_cast error if data exists, but it is the wrong type" );
        
        }
        { //::SireIO::AmberParm::title
        
            typedef ::QString ( ::SireIO::AmberParm::*title_function_type)(  ) const;
            title_function_type title_function_value( &::SireIO::AmberParm::title );
            
            AmberParm_exposer.def( 
                "title"
                , title_function_value
                , "Return the title of the parameter file" );
        
        }
        { //::SireIO::AmberParm::toString
        
            typedef ::QString ( ::SireIO::AmberParm::*toString_function_type)(  ) const;
            toString_function_type toString_function_value( &::SireIO::AmberParm::toString );
            
            AmberParm_exposer.def( 
                "toString"
                , toString_function_value
                , "Return a string representation of this object" );
        
        }
        { //::SireIO::AmberParm::typeName
        
            typedef char const * ( *typeName_function_type )(  );
            typeName_function_type typeName_function_value( &::SireIO::AmberParm::typeName );
            
            AmberParm_exposer.def( 
                "typeName"
                , typeName_function_value
                , "" );
        
        }
        { //::SireIO::AmberParm::what
        
            typedef char const * ( ::SireIO::AmberParm::*what_function_type)(  ) const;
            what_function_type what_function_value( &::SireIO::AmberParm::what );
            
            AmberParm_exposer.def( 
                "what"
                , what_function_value
                , "" );
        
        }
        AmberParm_exposer.staticmethod( "parse" );
        AmberParm_exposer.staticmethod( "typeName" );
        AmberParm_exposer.def( "__copy__", &__copy__);
        AmberParm_exposer.def( "__deepcopy__", &__copy__);
        AmberParm_exposer.def( "clone", &__copy__);
        AmberParm_exposer.def( "__rlshift__", &__rlshift__QDataStream< ::SireIO::AmberParm >,
                            bp::return_internal_reference<1, bp::with_custodian_and_ward<1,2> >() );
        AmberParm_exposer.def( "__rrshift__", &__rrshift__QDataStream< ::SireIO::AmberParm >,
                            bp::return_internal_reference<1, bp::with_custodian_and_ward<1,2> >() );
        AmberParm_exposer.def( "__str__", &__str__< ::SireIO::AmberParm > );
        AmberParm_exposer.def( "__repr__", &__str__< ::SireIO::AmberParm > );
    }

}
